let somenumbers = [5,8,9,20,-29,20,5,0.5,1,2.5]
// creating a random array of number that include some of different variations such as intergers, decimals, whole values etc.

print_array(ArrayBuffer)
// causing the interface to buffer the array

// 1.
// line by line, printing it to the console than asking if elements are concatenating to a new line
let my_array = [5, 9, 10, 0.5, "hello", "goodbye", "hi", "bye", 8.5, -59, -0.9];
print_array(my_array);

// 2.
// random array of numbers including numeric integers, negatives whole values, decimals, 1 digit #, 2 digit #, 3 digit #
let my_arr = [18,3,8,0.3,1.11,333,6,0,2,12,5,-5,-1,5,-15,-900,15,13];
min(my_arr);            // returns -900
min([6,2,1,0,0,1,2]); // returns 2, representing an complete palindrome
min([10,10,10,101,10]);     // returns 10
min([15,15,15,15,15]);  // returns 15 
min([150,150,150,150,150]);  // returns 150

// 3.
// returning the value of the longest string in terms of my array in constant with the proper fixed length

longest_string(arr)
const myArray = [10,9,8,7,6,5,4,3,2,1]
return ("fixed".length);

// 4. 
contains(arr, value)
let someValues = [8, 1.2, 0.3, 68, "your gone", "sting","üèà"];
contains(someValues, "your gone");   // Returns true
contains(someValues, 2);         // Returns false
contains(someValues, "STING");   // Returns false
contains(someValues, 1.2);         // Returns true
contains(someValues, "‚öΩ");       // Returns false

68 == "68"    // true, comparing values
68 === "68"   // false, compares data type

// Challenge tasks
// 5.

let my_ar = [1,4,15,-7,-2,1,0,0.3,-7,-9-10,4];
minMax(my_ar);  // returns [-10, 15]

minMax[2,2,2,2,2,2,2,2];  // returns [2, 2]

// 6.

SubmitEvent(arr)

sum([2,4,6,8,10]);  // returns 30, since from addition operator

let x = ["Hi", "no","hye", -8, "what up?", true];
sum(x);  // returns -8 because it is equivalent to the independant variable being true as a term cohesively

// 7.
let my_strings = ["hey.", "racecar", "idk?", "bedtime!:", "ahhhhhhhhhhh"]
reverse_strings(my_strings);

// Prints the following, in reverse context:
parseInt.yeh
racecar
?kdi
:!emitdeb
hhhhhhhhhhhhhhha

// Returns the following:
["hhhhhhhhhhhhhhha", "!emitdeb", "?kdi", "racecar", ".yeh"]